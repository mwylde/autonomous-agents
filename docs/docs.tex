\documentclass{article}

\usepackage{hyperref}
\usepackage{parskip}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{wrapfig}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}
\usepackage{fullpage}

\author{Micah Wylde\\Jeffrey Ruberg}
\date{\today}
\title{Autonomous Agents:\\
A Hybrid Dynamical System for Vehicle Navigation\\
Comp 352}

\begin{document}
\maketitle

\section{Introduction}
Self-driving cars hold much promise for saving fuel, time and
lives. Human-driven vehicles are responsible for millions of traffic
accidents and over 30,000 deaths annually in the US alone. Humans can
also make poor decisions in regards to routes, leading to traffic jams
and wasted fuel. Safe, effective autonomous cars could largely solve
these issues. AI researchers have been interested in the potential for
vehicular navigation since the 1960s. In order to spur development in
this area, the Defense Advanced Research Projects Agency (DARPA)
organized the Grand Challenge in 2004, which tasked contestants to
build cars which could autonomously navigate a 142 mile-long course in
the Mojave desert. Though none of the vehicles could finish the
course, a second competition the next year was more successful. Four
teams finished in the allotted time, traversing a treacherous 132 mile
desert course with no human guidance. Building on this achievement, in
2007 DARPA organized the Urban Challenge which took place in a
simulated suburban environment. To win, cars had to navigate a maze of
streets while accounting for other traffic and following California
traffic laws at all times. Six teams finished the 61 mile course with
the winner, ``Boss'' from CMU, taking a little more than four hours
\cite{robotic_cars}.

There are many challenges involved in autonomous driving and robot
navigation in general. In the real world one must deal with unreliable
and imperfect sensor data, imprecise localization technologies and
other perception issues. Even in simulation the challenges of
successful navigation are immense. Cars must follow traffic laws, get
to their destination quickly and efficiently and act safely at all
times, even in unexpected situations. As far as the actual navigation,
there are two general approaches: deliberative and reactive. As an
example of the former, $A^*$ is an efficient and optimal graph search
algorithm which is very effective at finding the best route between
two points but cannot handle the dynamism of the real world. Dynamical
navigation is a reactive strategy that uses force fields to guide
agents away from obstacles and towards their target. However, it is
purely local and has trouble finding optimal paths to distant
goals. In this paper we present simulated agents which use each
technique as well as a hybrid agent which makes use of $A*$ for global
navigation and dynamical systems for local navigation.


\section{Autonomous Driving}

\subsection{Simulation}

\section{Methods}

To create an autonomous agent that navigates while simulating a car's behavior
and traffic laws, we took three general approaches: deliberative planning
through A* search, reactive navigation through a dynamical system, and a hybrid
of deliberative planning and reactive motion. As for the agents' environment, we
create graphical worlds out of real map data. The code architecture consists of
a server and a separate client for each agent.

\subsection{Code Architecture}

The project is written in Ruby, under JRuby to utilize Java2D for the graphical
display. Specifically, all server code runs specifically under JRuby, but client
code can run under any flavor of Ruby. Agents are represented both on the client
and server end; server agents perform motion- and display-related
calculations, and client agents contain all the navigation inference and
decision-making and ultimately send decisions (restricted to behavior variables)
back to the server againt.

A brief description of the various source files will follow.

\begin{description}
\item[app.rb] This file is the point of entry for the program. This same entry
  point is used to, based on various command-line options, start a server, start
  a new agent, or run tests.

\item[client_agent.rb] This file contains the \code{ClientAgent} class, the
  super class which every client agent inherits. Client agents receive messages
  from remote server agents, process the message (based on their form of
  navigation), and then send back a response in their behavior variable space.

\item[constants.rb] This file contains various general constants that may be
  used in several locations or files, or that may be particularly useful to
  tweak with.

\item[display.rb] This file contains all of the display code used to generate
  our rendering of the world.

\item[map.rb] This file contains the classes, specifically \code{Map}, which
  encode information provided from real map data.

\item[pqueue.rb] A priority queue implementation useful for A* search.

\item[remote_agent.rb] This file contains the \code{RemoteServerAgent} class,
  which is a subclass of \code{ServerAgent}. Essentially, a remote server agent
  is a server agent which is tied to a specific client agent and communicates
  with that client agent.

\item[server_agnet.rb] This file contains the \code{ServerAgent} class, which
  contains all the base representation and calculations needed for an agent (for
  example, the server agent computes various points needed to display the agent
  graphically).

\item[server.rb] This file contains the socket server to which new agents
  connect.

\item[socket.rb] MICAH

\item[util.rb]

\item[agents/astar.rb]

\item[agents/dynamical.rb]

\item[agents/hybrid.rb]

\item[agents/simple.rb]

\subsection{Simulation Environment}

\subsection{Deliberative Planning}

\subsection{Reactive Navigation}

\subsection{Hybrid Approach}

\section{Results}

\section{Conclusion}

\end{document}
